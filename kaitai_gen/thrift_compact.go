// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

package kaitai_gen

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"


/**
 * Thrift Compact Protocol parser.
 * 
 * This format uses variable-length encoding and recursive structures that
 * terminate with a STOP field (byte 0x00). Fields are read using `repeat: until`
 * with a condition that checks if the last read field is a STOP field.
 * 
 * The struct parsing reads fields until a STOP field (field_header == 0x00) is
 * encountered, allowing proper handling of conditionally terminated recursive
 * structures.
 * @see <a href="https://github.com/apache/thrift/blob/master/doc/specs/thrift-compact-protocol.md">Source</a>
 */

type ThriftCompact_FieldType int
const (
	ThriftCompact_FieldType__Stop ThriftCompact_FieldType = 0
	ThriftCompact_FieldType__True ThriftCompact_FieldType = 1
	ThriftCompact_FieldType__False ThriftCompact_FieldType = 2
	ThriftCompact_FieldType__Byte ThriftCompact_FieldType = 3
	ThriftCompact_FieldType__I16 ThriftCompact_FieldType = 4
	ThriftCompact_FieldType__I32 ThriftCompact_FieldType = 5
	ThriftCompact_FieldType__I64 ThriftCompact_FieldType = 6
	ThriftCompact_FieldType__Double ThriftCompact_FieldType = 7
	ThriftCompact_FieldType__Binary ThriftCompact_FieldType = 8
	ThriftCompact_FieldType__List ThriftCompact_FieldType = 9
	ThriftCompact_FieldType__Set ThriftCompact_FieldType = 10
	ThriftCompact_FieldType__Map ThriftCompact_FieldType = 11
	ThriftCompact_FieldType__Struct ThriftCompact_FieldType = 12
)
var values_ThriftCompact_FieldType = map[ThriftCompact_FieldType]struct{}{0: {}, 1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {}, 7: {}, 8: {}, 9: {}, 10: {}, 11: {}, 12: {}}
func (v ThriftCompact_FieldType) isDefined() bool {
	_, ok := values_ThriftCompact_FieldType[v]
	return ok
}

type ThriftCompact_MessageType int
const (
	ThriftCompact_MessageType__Call ThriftCompact_MessageType = 1
	ThriftCompact_MessageType__Reply ThriftCompact_MessageType = 2
	ThriftCompact_MessageType__Exception ThriftCompact_MessageType = 3
	ThriftCompact_MessageType__Oneway ThriftCompact_MessageType = 4
)
var values_ThriftCompact_MessageType = map[ThriftCompact_MessageType]struct{}{1: {}, 2: {}, 3: {}, 4: {}}
func (v ThriftCompact_MessageType) isDefined() bool {
	_, ok := values_ThriftCompact_MessageType[v]
	return ok
}
type ThriftCompact struct {
	Message *ThriftCompact_CompactMessage
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent kaitai.Struct
}
func NewThriftCompact() *ThriftCompact {
	return &ThriftCompact{
	}
}

func (this ThriftCompact) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact) Read(io *kaitai.Stream, parent kaitai.Struct, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1 := NewThriftCompact_CompactMessage()
	err = tmp1.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Message = tmp1
	return err
}
type ThriftCompact_CompactField struct {
	FieldHeader uint8
	ExtendedDelta *ThriftCompact_VarintZ
	Value *ThriftCompact_CompactValue
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent *ThriftCompact_CompactStruct
	_f_fieldDelta bool
	fieldDelta int
	_f_fieldDeltaShort bool
	fieldDeltaShort int
	_f_fieldType bool
	fieldType int
	_f_hasExtendedDelta bool
	hasExtendedDelta bool
	_f_isStop bool
	isStop bool
}
func NewThriftCompact_CompactField() *ThriftCompact_CompactField {
	return &ThriftCompact_CompactField{
	}
}

func (this ThriftCompact_CompactField) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_CompactField) Read(io *kaitai.Stream, parent *ThriftCompact_CompactStruct, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp2, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.FieldHeader = tmp2
	tmp3, err := this.IsStop()
	if err != nil {
		return err
	}
	tmp4, err := this.HasExtendedDelta()
	if err != nil {
		return err
	}
	if ( ((!(tmp3)) && (tmp4)) ) {
		tmp5 := NewThriftCompact_VarintZ()
		err = tmp5.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.ExtendedDelta = tmp5
	}
	tmp6, err := this.IsStop()
	if err != nil {
		return err
	}
	if (!(tmp6)) {
		tmp7, err := this.FieldType()
		if err != nil {
			return err
		}
		tmp8 := NewThriftCompact_CompactValue(uint8(tmp7))
		err = tmp8.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Value = tmp8
	}
	return err
}

/**
 * Field id delta (if delta_short != 0) or absolute field id (if delta_short == 0)
 */
func (this *ThriftCompact_CompactField) FieldDelta() (v int, err error) {
	if (this._f_fieldDelta) {
		return this.fieldDelta, nil
	}
	this._f_fieldDelta = true
	var tmp9 int;
	tmp10, err := this.HasExtendedDelta()
	if err != nil {
		return 0, err
	}
	if (tmp10) {
		tmp11, err := this.ExtendedDelta.Value()
		if err != nil {
			return 0, err
		}
		tmp9 = tmp11
	} else {
		tmp12, err := this.FieldDeltaShort()
		if err != nil {
			return 0, err
		}
		tmp9 = tmp12
	}
	this.fieldDelta = int(tmp9)
	return this.fieldDelta, nil
}

/**
 * Field delta from header (bits 4-7)
 */
func (this *ThriftCompact_CompactField) FieldDeltaShort() (v int, err error) {
	if (this._f_fieldDeltaShort) {
		return this.fieldDeltaShort, nil
	}
	this._f_fieldDeltaShort = true
	this.fieldDeltaShort = int((this.FieldHeader >> 4) & 15)
	return this.fieldDeltaShort, nil
}

/**
 * Field type (bits 0-3)
 */
func (this *ThriftCompact_CompactField) FieldType() (v int, err error) {
	if (this._f_fieldType) {
		return this.fieldType, nil
	}
	this._f_fieldType = true
	this.fieldType = int(this.FieldHeader & 15)
	return this.fieldType, nil
}

/**
 * True if full field id follows as varint (instead of delta)
 */
func (this *ThriftCompact_CompactField) HasExtendedDelta() (v bool, err error) {
	if (this._f_hasExtendedDelta) {
		return this.hasExtendedDelta, nil
	}
	this._f_hasExtendedDelta = true
	tmp13, err := this.FieldDeltaShort()
	if err != nil {
		return false, err
	}
	this.hasExtendedDelta = bool(tmp13 == 0)
	return this.hasExtendedDelta, nil
}

/**
 * True if this is a STOP field
 */
func (this *ThriftCompact_CompactField) IsStop() (v bool, err error) {
	if (this._f_isStop) {
		return this.isStop, nil
	}
	this._f_isStop = true
	this.isStop = bool(this.FieldHeader == 0)
	return this.isStop, nil
}

/**
 * Field header byte. If this is 0x00, it's a STOP field.
 * Otherwise:
 * - Bits 0-3: field type (0-15)
 * - Bits 4-7: field delta (0-15, or 0 if delta follows as varint)
 */

/**
 * Full field id (i16, zigzag varint) when header delta is 0
 */

/**
 * Field value (type depends on field_type)
 */
type ThriftCompact_CompactList struct {
	ListHeader uint8
	ExtendedSize *ThriftCompact_VarintU
	Elements []*ThriftCompact_CompactValue
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent *ThriftCompact_CompactValue
	_f_elementType bool
	elementType int
	_f_hasExtendedSize bool
	hasExtendedSize bool
	_f_listSize bool
	listSize int
	_f_listSizeShort bool
	listSizeShort int
}
func NewThriftCompact_CompactList() *ThriftCompact_CompactList {
	return &ThriftCompact_CompactList{
	}
}

func (this ThriftCompact_CompactList) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_CompactList) Read(io *kaitai.Stream, parent *ThriftCompact_CompactValue, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp14, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.ListHeader = tmp14
	tmp15, err := this.HasExtendedSize()
	if err != nil {
		return err
	}
	if (tmp15) {
		tmp16 := NewThriftCompact_VarintU()
		err = tmp16.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.ExtendedSize = tmp16
	}
	tmp17, err := this.ListSize()
	if err != nil {
		return err
	}
	for i := 0; i < int(tmp17); i++ {
		_ = i
		tmp18, err := this.ElementType()
		if err != nil {
			return err
		}
		tmp19 := NewThriftCompact_CompactValue(uint8(tmp18))
		err = tmp19.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Elements = append(this.Elements, tmp19)
	}
	return err
}

/**
 * Element type (0-15)
 */
func (this *ThriftCompact_CompactList) ElementType() (v int, err error) {
	if (this._f_elementType) {
		return this.elementType, nil
	}
	this._f_elementType = true
	this.elementType = int(this.ListHeader & 15)
	return this.elementType, nil
}

/**
 * True if extended size follows as varint
 */
func (this *ThriftCompact_CompactList) HasExtendedSize() (v bool, err error) {
	if (this._f_hasExtendedSize) {
		return this.hasExtendedSize, nil
	}
	this._f_hasExtendedSize = true
	tmp20, err := this.ListSizeShort()
	if err != nil {
		return false, err
	}
	this.hasExtendedSize = bool(tmp20 == 15)
	return this.hasExtendedSize, nil
}

/**
 * Final list size
 */
func (this *ThriftCompact_CompactList) ListSize() (v int, err error) {
	if (this._f_listSize) {
		return this.listSize, nil
	}
	this._f_listSize = true
	var tmp21 int;
	tmp22, err := this.HasExtendedSize()
	if err != nil {
		return 0, err
	}
	if (tmp22) {
		tmp23, err := this.ExtendedSize.ValueU()
		if err != nil {
			return 0, err
		}
		tmp21 = tmp23
	} else {
		tmp24, err := this.ListSizeShort()
		if err != nil {
			return 0, err
		}
		tmp21 = tmp24
	}
	this.listSize = int(tmp21)
	return this.listSize, nil
}

/**
 * List size from header (0-14, or 15 if extended)
 */
func (this *ThriftCompact_CompactList) ListSizeShort() (v int, err error) {
	if (this._f_listSizeShort) {
		return this.listSizeShort, nil
	}
	this._f_listSizeShort = true
	this.listSizeShort = int((this.ListHeader >> 4) & 15)
	return this.listSizeShort, nil
}

/**
 * List header: size (upper 4 bits) and element type (lower 4 bits)
 * If size == 15, actual size follows as varint
 */

/**
 * Actual list size (if header size was 15)
 */

/**
 * List elements
 */
type ThriftCompact_CompactMap struct {
	Size *ThriftCompact_VarintU
	TypeByte uint8
	Entries []*ThriftCompact_MapEntry
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent *ThriftCompact_CompactValue
	_f_keyType bool
	keyType int
	_f_mapSize bool
	mapSize int
	_f_valueType bool
	valueType int
}
func NewThriftCompact_CompactMap() *ThriftCompact_CompactMap {
	return &ThriftCompact_CompactMap{
	}
}

func (this ThriftCompact_CompactMap) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_CompactMap) Read(io *kaitai.Stream, parent *ThriftCompact_CompactValue, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp25 := NewThriftCompact_VarintU()
	err = tmp25.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Size = tmp25
	tmp26, err := this.MapSize()
	if err != nil {
		return err
	}
	if (tmp26 != 0) {
		tmp27, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.TypeByte = tmp27
	}
	tmp28, err := this.MapSize()
	if err != nil {
		return err
	}
	for i := 0; i < int(tmp28); i++ {
		_ = i
		tmp29, err := this.KeyType()
		if err != nil {
			return err
		}
		tmp30, err := this.ValueType()
		if err != nil {
			return err
		}
		tmp31 := NewThriftCompact_MapEntry(uint8(tmp29), uint8(tmp30))
		err = tmp31.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp31)
	}
	return err
}

/**
 * Key type (0-15)
 */
func (this *ThriftCompact_CompactMap) KeyType() (v int, err error) {
	if (this._f_keyType) {
		return this.keyType, nil
	}
	this._f_keyType = true
	var tmp32 int;
	tmp33, err := this.MapSize()
	if err != nil {
		return 0, err
	}
	if (tmp33 == 0) {
		tmp32 = 0
	} else {
		tmp32 = int((this.TypeByte >> 4) & 15)
	}
	this.keyType = tmp32
	return this.keyType, nil
}

/**
 * Map size
 */
func (this *ThriftCompact_CompactMap) MapSize() (v int, err error) {
	if (this._f_mapSize) {
		return this.mapSize, nil
	}
	this._f_mapSize = true
	tmp34, err := this.Size.ValueU()
	if err != nil {
		return 0, err
	}
	this.mapSize = int(tmp34)
	return this.mapSize, nil
}

/**
 * Value type (0-15)
 */
func (this *ThriftCompact_CompactMap) ValueType() (v int, err error) {
	if (this._f_valueType) {
		return this.valueType, nil
	}
	this._f_valueType = true
	var tmp35 int;
	tmp36, err := this.MapSize()
	if err != nil {
		return 0, err
	}
	if (tmp36 == 0) {
		tmp35 = 0
	} else {
		tmp35 = int(this.TypeByte & 15)
	}
	this.valueType = tmp35
	return this.valueType, nil
}

/**
 * Map size (unsigned varint).
 * In Thrift Compact Protocol the map header is:
 * - if size == 0: just the size varint (0x00), and nothing else
 * - else: size varint, then one byte: (key_type << 4) | value_type
 */

/**
 * Key/value types packed into nibbles high=key, low=value
 */

/**
 * Map entries
 */
type ThriftCompact_CompactMessage struct {
	ProtocolId uint8
	VersionAndType uint8
	SeqId *ThriftCompact_VarintZ
	Name *ThriftCompact_CompactString
	Fields *ThriftCompact_CompactStruct
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent *ThriftCompact
	_f_msgType bool
	msgType int
	_f_version bool
	version int
}
func NewThriftCompact_CompactMessage() *ThriftCompact_CompactMessage {
	return &ThriftCompact_CompactMessage{
	}
}

func (this ThriftCompact_CompactMessage) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_CompactMessage) Read(io *kaitai.Stream, parent *ThriftCompact, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp37, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.ProtocolId = tmp37
	if !(this.ProtocolId == 130) {
		return kaitai.NewValidationNotEqualError(130, this.ProtocolId, this._io, "/types/compact_message/seq/0")
	}
	tmp38, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.VersionAndType = tmp38
	tmp39 := NewThriftCompact_VarintZ()
	err = tmp39.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.SeqId = tmp39
	tmp40 := NewThriftCompact_CompactString()
	err = tmp40.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Name = tmp40
	tmp41 := NewThriftCompact_CompactStruct()
	err = tmp41.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Fields = tmp41
	return err
}

/**
 * Message type (1=call, 2=reply, 3=exception, 4=oneway)
 */
func (this *ThriftCompact_CompactMessage) MsgType() (v int, err error) {
	if (this._f_msgType) {
		return this.msgType, nil
	}
	this._f_msgType = true
	this.msgType = int(this.VersionAndType & 15)
	return this.msgType, nil
}

/**
 * Protocol version
 */
func (this *ThriftCompact_CompactMessage) Version() (v int, err error) {
	if (this._f_version) {
		return this.version, nil
	}
	this._f_version = true
	this.version = int((this.VersionAndType >> 4) & 15)
	return this.version, nil
}

/**
 * Protocol ID (must be 0x82 for compact protocol)
 */

/**
 * Version (4 bits) and message type (4 bits)
 */

/**
 * Sequence ID (zigzag-encoded)
 */

/**
 * Method name
 */

/**
 * Message fields (struct)
 */
type ThriftCompact_CompactString struct {
	Len *ThriftCompact_VarintU
	Value string
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent kaitai.Struct
	_f_length bool
	length int
}
func NewThriftCompact_CompactString() *ThriftCompact_CompactString {
	return &ThriftCompact_CompactString{
	}
}

func (this ThriftCompact_CompactString) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_CompactString) Read(io *kaitai.Stream, parent kaitai.Struct, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp42 := NewThriftCompact_VarintU()
	err = tmp42.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Len = tmp42
	tmp43, err := this.Length()
	if err != nil {
		return err
	}
	tmp44, err := this._io.ReadBytes(int(tmp43))
	if err != nil {
		return err
	}
	tmp44 = tmp44
	this.Value = string(tmp44)
	return err
}

/**
 * Decoded string length
 */
func (this *ThriftCompact_CompactString) Length() (v int, err error) {
	if (this._f_length) {
		return this.length, nil
	}
	this._f_length = true
	tmp45, err := this.Len.ValueU()
	if err != nil {
		return 0, err
	}
	this.length = int(tmp45)
	return this.length, nil
}

/**
 * String length (unsigned varint)
 */

/**
 * String value
 */
type ThriftCompact_CompactStruct struct {
	Fields []*ThriftCompact_CompactField
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent kaitai.Struct
}
func NewThriftCompact_CompactStruct() *ThriftCompact_CompactStruct {
	return &ThriftCompact_CompactStruct{
	}
}

func (this ThriftCompact_CompactStruct) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_CompactStruct) Read(io *kaitai.Stream, parent kaitai.Struct, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 1;; i++ {
		tmp46 := NewThriftCompact_CompactField()
		err = tmp46.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		_it := tmp46
		this.Fields = append(this.Fields, _it)
		tmp47, err := _it.IsStop()
		if err != nil {
			return err
		}
		if tmp47 {
			break
		}
	}
	return err
}

/**
 * Fields of the struct. Uses `repeat: until` to read fields until
 * a STOP field is encountered.
 * 
 * The condition `_.is_stop` checks if the last read field
 * is a STOP field (field_header == 0x00). When a STOP field is detected,
 * the loop terminates.
 * 
 * Each field is fully read before checking if it's a STOP field, which
 * means the STOP field itself is included in the fields array.
 */

/**
 * Value of the field, type depends on value_type parameter
 */
type ThriftCompact_CompactValue struct {
	ByteValue int8
	I16Value *ThriftCompact_VarintZ
	I32Value *ThriftCompact_VarintZ
	I64Value *ThriftCompact_VarintZ
	DoubleValue float64
	BinaryValue *ThriftCompact_CompactString
	ListValue *ThriftCompact_CompactList
	SetValue *ThriftCompact_CompactList
	MapValue *ThriftCompact_CompactMap
	StructValue *ThriftCompact_CompactStruct
	ValueType uint8
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent kaitai.Struct
}
func NewThriftCompact_CompactValue(valueType uint8) *ThriftCompact_CompactValue {
	return &ThriftCompact_CompactValue{
		ValueType: valueType,
	}
}

func (this ThriftCompact_CompactValue) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_CompactValue) Read(io *kaitai.Stream, parent kaitai.Struct, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	if (this.ValueType == 3) {
		tmp48, err := this._io.ReadS1()
		if err != nil {
			return err
		}
		this.ByteValue = tmp48
	}
	if (this.ValueType == 4) {
		tmp49 := NewThriftCompact_VarintZ()
		err = tmp49.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.I16Value = tmp49
	}
	if (this.ValueType == 5) {
		tmp50 := NewThriftCompact_VarintZ()
		err = tmp50.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.I32Value = tmp50
	}
	if (this.ValueType == 6) {
		tmp51 := NewThriftCompact_VarintZ()
		err = tmp51.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.I64Value = tmp51
	}
	if (this.ValueType == 7) {
		tmp52, err := this._io.ReadF8le()
		if err != nil {
			return err
		}
		this.DoubleValue = float64(tmp52)
	}
	if (this.ValueType == 8) {
		tmp53 := NewThriftCompact_CompactString()
		err = tmp53.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.BinaryValue = tmp53
	}
	if (this.ValueType == 9) {
		tmp54 := NewThriftCompact_CompactList()
		err = tmp54.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.ListValue = tmp54
	}
	if (this.ValueType == 10) {
		tmp55 := NewThriftCompact_CompactList()
		err = tmp55.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.SetValue = tmp55
	}
	if (this.ValueType == 11) {
		tmp56 := NewThriftCompact_CompactMap()
		err = tmp56.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.MapValue = tmp56
	}
	if (this.ValueType == 12) {
		tmp57 := NewThriftCompact_CompactStruct()
		err = tmp57.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.StructValue = tmp57
	}
	return err
}
type ThriftCompact_MapEntry struct {
	Key *ThriftCompact_CompactValue
	Value *ThriftCompact_CompactValue
	KeyType uint8
	ValType uint8
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent *ThriftCompact_CompactMap
}
func NewThriftCompact_MapEntry(keyType uint8, valType uint8) *ThriftCompact_MapEntry {
	return &ThriftCompact_MapEntry{
		KeyType: keyType,
		ValType: valType,
	}
}

func (this ThriftCompact_MapEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_MapEntry) Read(io *kaitai.Stream, parent *ThriftCompact_CompactMap, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp58 := NewThriftCompact_CompactValue(this.KeyType)
	err = tmp58.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Key = tmp58
	tmp59 := NewThriftCompact_CompactValue(this.ValType)
	err = tmp59.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Value = tmp59
	return err
}

/**
 * Map key
 */

/**
 * Map value
 */
type ThriftCompact_VarintU struct {
	Bytes []uint8
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent kaitai.Struct
	_f_valueU bool
	valueU int
}
func NewThriftCompact_VarintU() *ThriftCompact_VarintU {
	return &ThriftCompact_VarintU{
	}
}

func (this ThriftCompact_VarintU) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_VarintU) Read(io *kaitai.Stream, parent kaitai.Struct, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 1;; i++ {
		tmp60, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		_it := tmp60
		this.Bytes = append(this.Bytes, _it)
		if _it & 128 == 0 {
			break
		}
	}
	return err
}

/**
 * Decoded unsigned integer value
 */
func (this *ThriftCompact_VarintU) ValueU() (v int, err error) {
	if (this._f_valueU) {
		return this.valueU, nil
	}
	this._f_valueU = true
	var tmp61 int;
	if (len(this.Bytes) > 1) {
		tmp61 = int(this.Bytes[1] & 127) << 7
	} else {
		tmp61 = 0
	}
	var tmp62 int;
	if (len(this.Bytes) > 2) {
		tmp62 = int(this.Bytes[2] & 127) << 14
	} else {
		tmp62 = 0
	}
	var tmp63 int;
	if (len(this.Bytes) > 3) {
		tmp63 = int(this.Bytes[3] & 127) << 21
	} else {
		tmp63 = 0
	}
	var tmp64 int;
	if (len(this.Bytes) > 4) {
		tmp64 = int(this.Bytes[4] & 127) << 28
	} else {
		tmp64 = 0
	}
	var tmp65 int;
	if (len(this.Bytes) > 5) {
		tmp65 = int(this.Bytes[5] & 127) << 35
	} else {
		tmp65 = 0
	}
	var tmp66 int;
	if (len(this.Bytes) > 6) {
		tmp66 = int(this.Bytes[6] & 127) << 42
	} else {
		tmp66 = 0
	}
	var tmp67 int;
	if (len(this.Bytes) > 7) {
		tmp67 = int(this.Bytes[7] & 127) << 49
	} else {
		tmp67 = 0
	}
	var tmp68 int;
	if (len(this.Bytes) > 8) {
		tmp68 = int(this.Bytes[8] & 127) << 56
	} else {
		tmp68 = 0
	}
	var tmp69 int;
	if (len(this.Bytes) > 9) {
		tmp69 = int(this.Bytes[9] & 127) << 63
	} else {
		tmp69 = 0
	}
	this.valueU = int(((((((((int(this.Bytes[0] & 127) + tmp61) + tmp62) + tmp63) + tmp64) + tmp65) + tmp66) + tmp67) + tmp68) + tmp69)
	return this.valueU, nil
}

/**
 * Unsigned variable-length integer encoding (base-128 LE).
 * Each byte: bit 7 = continuation flag, bits 0-6 = data.
 */
type ThriftCompact_VarintZ struct {
	Bytes []uint8
	_io *kaitai.Stream
	_root *ThriftCompact
	_parent kaitai.Struct
	_f_value bool
	value int
	_f_valueU bool
	valueU int
}
func NewThriftCompact_VarintZ() *ThriftCompact_VarintZ {
	return &ThriftCompact_VarintZ{
	}
}

func (this ThriftCompact_VarintZ) IO_() *kaitai.Stream {
	return this._io
}

func (this *ThriftCompact_VarintZ) Read(io *kaitai.Stream, parent kaitai.Struct, root *ThriftCompact) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 1;; i++ {
		tmp70, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		_it := tmp70
		this.Bytes = append(this.Bytes, _it)
		if _it & 128 == 0 {
			break
		}
	}
	return err
}

/**
 * Decoded zigzag-signed integer value
 */
func (this *ThriftCompact_VarintZ) Value() (v int, err error) {
	if (this._f_value) {
		return this.value, nil
	}
	this._f_value = true
	tmp71, err := this.ValueU()
	if err != nil {
		return 0, err
	}
	tmp72, err := this.ValueU()
	if err != nil {
		return 0, err
	}
	this.value = int(tmp71 >> 1 ^ -(tmp72 & 1))
	return this.value, nil
}

/**
 * Decoded unsigned integer value (before zigzag)
 */
func (this *ThriftCompact_VarintZ) ValueU() (v int, err error) {
	if (this._f_valueU) {
		return this.valueU, nil
	}
	this._f_valueU = true
	var tmp73 int;
	if (len(this.Bytes) > 1) {
		tmp73 = int(this.Bytes[1] & 127) << 7
	} else {
		tmp73 = 0
	}
	var tmp74 int;
	if (len(this.Bytes) > 2) {
		tmp74 = int(this.Bytes[2] & 127) << 14
	} else {
		tmp74 = 0
	}
	var tmp75 int;
	if (len(this.Bytes) > 3) {
		tmp75 = int(this.Bytes[3] & 127) << 21
	} else {
		tmp75 = 0
	}
	var tmp76 int;
	if (len(this.Bytes) > 4) {
		tmp76 = int(this.Bytes[4] & 127) << 28
	} else {
		tmp76 = 0
	}
	var tmp77 int;
	if (len(this.Bytes) > 5) {
		tmp77 = int(this.Bytes[5] & 127) << 35
	} else {
		tmp77 = 0
	}
	var tmp78 int;
	if (len(this.Bytes) > 6) {
		tmp78 = int(this.Bytes[6] & 127) << 42
	} else {
		tmp78 = 0
	}
	var tmp79 int;
	if (len(this.Bytes) > 7) {
		tmp79 = int(this.Bytes[7] & 127) << 49
	} else {
		tmp79 = 0
	}
	var tmp80 int;
	if (len(this.Bytes) > 8) {
		tmp80 = int(this.Bytes[8] & 127) << 56
	} else {
		tmp80 = 0
	}
	var tmp81 int;
	if (len(this.Bytes) > 9) {
		tmp81 = int(this.Bytes[9] & 127) << 63
	} else {
		tmp81 = 0
	}
	this.valueU = int(((((((((int(this.Bytes[0] & 127) + tmp73) + tmp74) + tmp75) + tmp76) + tmp77) + tmp78) + tmp79) + tmp80) + tmp81)
	return this.valueU, nil
}

/**
 * Zigzag-encoded variable-length integer (base-128 LE).
 */
